diff -Naur linux-libreelec/drivers/amlogic/display/vout/enc_clk_config.c linux-datrh/drivers/amlogic/display/vout/enc_clk_config.c
--- linux-libreelec/drivers/amlogic/display/vout/enc_clk_config.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/display/vout/enc_clk_config.c	2017-08-30 21:17:34.000000000 +0200
@@ -84,6 +84,7 @@
     aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x40238100);
     aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00012286);
     aml_write_reg32(P_HHI_VID2_PLL_CNTL2, 0x430a800);       // internal LDO share with HPLL & VIID PLL
+    aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0x21ef, 0, 15);
     switch(clk){
         case 2971:      // only for 4k mode
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
diff -Naur linux-libreelec/drivers/amlogic/display/vout/tvconf.c linux-datrh/drivers/amlogic/display/vout/tvconf.c
--- linux-libreelec/drivers/amlogic/display/vout/tvconf.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/display/vout/tvconf.c	2018-06-05 21:45:54.000000000 +0200
@@ -425,7 +425,7 @@
         .aspect_ratio_den  = 9,
         .sync_duration_num = 24000,
         .sync_duration_den = 1001,
-        .video_clk         = 74250000,
+        .video_clk         = 74176000,//74250000,
     },
 #endif
     { /* VMODE_4K2K_30HZ */



 
diff -Naur linux-libreelec/sound/core/control.c linux-datrh/sound/core/control.c
--- linux-libreelec/sound/core/control.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/core/control.c	2018-06-05 21:45:46.000000000 +0200
@@ -1088,7 +1088,7 @@
 		mutex_lock(&ue->card->user_ctl_lock);
 		change = ue->tlv_data_size != size;
 		if (!change)
-			change = memcmp(ue->tlv_data, new_data, size) != 0;
+			change = memcmp(ue->tlv_data, new_data, size);
 		kfree(ue->tlv_data);
 		ue->tlv_data = new_data;
 		ue->tlv_data_size = size;
diff -Naur linux-libreelec/sound/core/seq/seq_clientmgr.c linux-datrh/sound/core/seq/seq_clientmgr.c
--- linux-libreelec/sound/core/seq/seq_clientmgr.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/core/seq/seq_clientmgr.c	2018-06-05 21:45:53.000000000 +0200
@@ -1248,7 +1248,6 @@
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_info info;
 	struct snd_seq_port_callback *callback;
-	int port_idx;
 
 	if (copy_from_user(&info, arg, sizeof(info)))
 		return -EFAULT;
@@ -1262,9 +1261,7 @@
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info.kernel) {
-		port_idx = port->addr.port;
-		snd_seq_port_unlock(port);
-		snd_seq_delete_port(client, port_idx);
+		snd_seq_delete_port(client, port->addr.port);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
@@ -1286,7 +1283,6 @@
 
 	snd_seq_set_port_info(port, &info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
-	snd_seq_port_unlock(port);
 
 	if (copy_to_user(arg, &info, sizeof(info)))
 		return -EFAULT;
diff -Naur linux-libreelec/sound/core/seq/seq_ports.c linux-datrh/sound/core/seq/seq_ports.c
--- linux-libreelec/sound/core/seq/seq_ports.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/core/seq/seq_ports.c	2017-08-30 21:17:34.000000000 +0200
@@ -122,9 +122,7 @@
 }
 
 
-/* create a port, port number is returned (-1 on failure);
- * the caller needs to unref the port via snd_seq_port_unlock() appropriately
- */
+/* create a port, port number is returned (-1 on failure) */
 struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
@@ -155,7 +153,6 @@
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
-	snd_use_lock_use(&new_port->use_lock);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
@@ -170,9 +167,9 @@
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
-	sprintf(new_port->name, "port-%d", num);
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
+	sprintf(new_port->name, "port-%d", num);
 
 	return new_port;
 }
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_audio_hw.c linux-datrh/sound/soc/aml/m8/aml_audio_hw.c
--- linux-libreelec/sound/soc/aml/m8/aml_audio_hw.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_audio_hw.c	2017-08-30 21:17:34.000000000 +0200
@@ -159,8 +159,8 @@
     if(channel == 8){
         printk(" %s channel == 8\n",__FUNCTION__);
         WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,       (24 << 16) |    // [31:16] IRQ block.
-                                (0xff << 8) |   // [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
-                                (0xff << 0));   // [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
+                                (((1 << channel) - 1) << 8) |   // [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
+                                (((1 << channel) - 1) << 0));   // [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
         }
     else 
         WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,       (24 << 16) |    // [31:16] IRQ block.
@@ -179,8 +179,10 @@
     audio_out_buf_ready = 1;
 }
 
-void audio_set_958outbuf(u32 addr, u32 size,int flag)
+void audio_set_958outbuf(u32 addr, u32 size, int channels, int flag)
 {
+	u8 chanmask;
+
     if (ENABLE_IEC958) {
         WRITE_MPEG_REG(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
         if(READ_MPEG_REG(AIU_MEM_IEC958_START_PTR) == READ_MPEG_REG(AIU_MEM_I2S_START_PTR)){
@@ -193,7 +195,8 @@
         }else{
             WRITE_MPEG_REG(AIU_MEM_IEC958_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 1);    // this is for RAW mode
         }
-        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_MASKS, 0x303, 0, 16);
+		chanmask = (1 << channels) - 1;
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_MASKS, chanmask << 8 | chanmask, 0, 16);
 
         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 0, 1);
         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 0, 1);
@@ -447,7 +450,7 @@
             WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 1, 5, 1);
         }
 
-        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_MASKS, mask[mode], 0, 16);
+//        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_MASKS, mask[mode], 0, 16);
 
         //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 0, 1);
         //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 0, 1);
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_audio_hw.h linux-datrh/sound/soc/aml/m8/aml_audio_hw.h
--- linux-libreelec/sound/soc/aml/m8/aml_audio_hw.h	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_audio_hw.h	2017-08-30 21:17:34.000000000 +0200
@@ -105,7 +105,7 @@
 extern unsigned I2S_MODE;
 
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel);
-void audio_set_958outbuf(u32 addr, u32 size, int flag);
+void audio_set_958outbuf(u32 addr, u32 size, int channels, int flag);
 void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode, u32 i2s_sync);
 void audio_in_spdif_set_buf(u32 addr, u32 size);
 void audio_in_i2s_enable(int flag);
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_i2s.c linux-datrh/sound/soc/aml/m8/aml_i2s.c
--- linux-libreelec/sound/soc/aml/m8/aml_i2s.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_i2s.c	2017-08-30 21:17:34.000000000 +0200
@@ -88,7 +88,7 @@
 // timer count: 16bits
 #define TIMER_COUNT    100
 
-#define USE_HW_TIMER
+//#define USE_HW_TIMER
 
 #ifdef USE_HW_TIMER
 static DEFINE_MUTEX(timer_mutex);
@@ -665,6 +665,16 @@
 extern void aml_hw_iec958_init(struct snd_pcm_substream *substream);
 extern void audio_hw_958_enable(unsigned flag);
 
+static char *get_hw_buf_ptr(struct snd_pcm_runtime *runtime, snd_pcm_uframes_t cur_pos, int align)
+{
+	unsigned int tot_bytes_per_channel = frames_to_bytes(runtime, cur_pos) / runtime->channels;
+	unsigned int bytes_aligned_per_channel = frames_to_bytes(runtime, align / runtime->channels);
+	unsigned int hw_base_off = tot_bytes_per_channel / bytes_aligned_per_channel;
+	unsigned int block_off = tot_bytes_per_channel % bytes_aligned_per_channel;
+
+	return runtime->dma_area + (frames_to_bytes(runtime, align) * hw_base_off) + block_off;
+}
+
 static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
                                  snd_pcm_uframes_t pos,
                                  void __user *buf, snd_pcm_uframes_t count, struct snd_pcm_substream *substream)
@@ -692,35 +702,21 @@
     }
     if (access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count))) {
         if (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
+       int16_t * tfrom, *to, *left;
+       int16_t *right = NULL;
 
-            int16_t * tfrom, *to, *left, *right;
-            tfrom = (int16_t*)ubuf;
-            to = (int16_t*)hwbuf;
-
-            left = to;
-            right = to + 16;
-            if (pos % align) {
-                printk("audio data unligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
-            }
-            if (set_android_gain_enable == 0) {
-                for (j = 0; j < n; j += 64) {
-                    for (i = 0; i < 16; i++) {
-                        *left++ = (*tfrom++) ;
-                        *right++ = (*tfrom++);
-                    }
-                    left += 16;
-                    right += 16;
-                }
-            } else {
-                for (j = 0; j < n; j += 64) {
-                    for (i = 0; i < 16; i++) {
-                        *left++ = (int16_t)(((*tfrom++) * android_left_gain) >> 8);
-                        *right++ = (int16_t)(((*tfrom++) * android_right_gain) >> 8);
-                    }
-                    left += 16;
-                    right += 16;
-                }
-            }
+	tfrom = (int16_t *) ubuf;
+
+	for (j = 0; j < count; j++) {
+		to = (int16_t *) get_hw_buf_ptr(runtime, pos + j, align);
+		left = to;
+		if (runtime->channels != 1)
+			right = to + align;
+
+		*left = (*tfrom++);
+		if (runtime->channels != 1)
+			*right = (*tfrom++);
+	}
         } else if (runtime->format == SNDRV_PCM_FORMAT_S24_LE && I2S_MODE == AIU_I2S_MODE_PCM24) {
             int32_t *tfrom, *to, *left, *right;
             tfrom = (int32_t*)ubuf;
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_m8.c linux-datrh/sound/soc/aml/m8/aml_m8.c
--- linux-libreelec/sound/soc/aml/m8/aml_m8.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_m8.c	2017-08-30 21:17:34.000000000 +0200
@@ -367,7 +367,6 @@
     struct aml_audio_private_data * p_aml_audio;
     int hp_state;
 
-    printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
     p_aml_audio = snd_soc_card_get_drvdata(card);
 	hp_state = p_aml_audio->detect_flag;
 
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_spdif_codec.c linux-datrh/sound/soc/aml/m8/aml_spdif_codec.c
--- linux-libreelec/sound/soc/aml/m8/aml_spdif_codec.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_spdif_codec.c	2017-08-30 21:17:34.000000000 +0200
@@ -25,8 +25,8 @@
 
 #define DRV_NAME "spdif-dit"
 
-#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
-#define STUB_FORMATS	SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE
+#define STUB_RATES	SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000
+#define STUB_FORMATS	SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE
 
 
 static struct snd_soc_codec_driver soc_codec_spdif_dit;
@@ -37,15 +37,15 @@
 	.name		= "dit-hifi",
 	.playback 	= {
 		.stream_name	= "Playback",
-		.channels_min	= 1,
-		.channels_max	= 8,
+		.channels_min	= 2,
+		.channels_max	= 2,
 		.rates		= STUB_RATES,
 		.formats	= STUB_FORMATS,
 	},
 	.capture 	= {
 		.stream_name	= "Capture",
-		.channels_min	= 1,
-		.channels_max	= 8,
+		.channels_min	= 2,
+		.channels_max	= 2,
 		.rates		= STUB_RATES,
 		.formats	= STUB_FORMATS,
 	},
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_spdif_dai.c linux-datrh/sound/soc/aml/m8/aml_spdif_dai.c
--- linux-libreelec/sound/soc/aml/m8/aml_spdif_dai.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_spdif_dai.c	2017-08-30 21:17:34.000000000 +0200
@@ -70,7 +70,7 @@
        }
 	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
 	memset(iec958buf, 0, sizeof(iec958buf));
-	audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63), 128, 0);
+	audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63), 128, 2, 0);
 	audio_set_958_mode(AIU_958_MODE_PCM16, &set);
 #if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1
 	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 3, 4, 2);	/* 512fs divide 4 == 128fs */
@@ -274,7 +274,7 @@
 		}
 		start = buf->addr;
 		size = snd_pcm_lib_buffer_bytes(substream);
-		audio_set_958outbuf(start, size, 0);
+		audio_set_958outbuf(start, size, runtime->channels, 0);
 		/* audio_set_i2s_mode(AIU_I2S_MODE_PCM16); */
 		/* audio_set_aiubuf(start, size); */
 	} else {
@@ -306,7 +306,7 @@
 		}
 		start = buf->addr;
 		size = snd_pcm_lib_buffer_bytes(substream);
-		audio_set_958outbuf(start, size,
+		audio_set_958outbuf(start, size, runtime->channels,
 				    (iec958_mode == AIU_958_MODE_RAW) ? 1 : 0);
 		memset((void *)buf->area, 0, size);
 	
}
