diff -Naur linux-libreelec/drivers/amlogic/amports/vh264_4k2k.c linux-datrh/drivers/amlogic/amports/vh264_4k2k.c
--- linux-libreelec/drivers/amlogic/amports/vh264_4k2k.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/amports/vh264_4k2k.c	2018-06-05 21:45:53.000000000 +0200
@@ -97,7 +97,7 @@
 static struct timer_list recycle_timer;
 static u32 stat;
 static u32 error_watchdog_count;
-static uint error_recovery_mode = 0;
+static uint error_recovery_mode = 1;
 static u32 sync_outside;
 static u32 vh264_4k2k_rotation;
 static u32 first_i_recieved;
diff -Naur linux-libreelec/drivers/amlogic/amports/vh264.c linux-datrh/drivers/amlogic/amports/vh264.c
--- linux-libreelec/drivers/amlogic/amports/vh264.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/amports/vh264.c	2018-06-05 21:45:53.000000000 +0200
@@ -237,7 +237,7 @@
 static u32 last_pts, last_pts_remainder;
 static bool check_pts_discontinue;
 static u32 wait_buffer_counter;
-static uint error_recovery_mode = 0;
+static uint error_recovery_mode = 1;
 static uint error_recovery_mode_in = 3;
 static uint error_recovery_mode_use = 3;
 
diff -Naur linux-libreelec/drivers/amlogic/camera/Makefile linux-datrh/drivers/amlogic/camera/Makefile
--- linux-libreelec/drivers/amlogic/camera/Makefile	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/camera/Makefile	2017-08-30 21:17:34.000000000 +0200
@@ -1,7 +1,6 @@
 #
 # Makefile for the amlogic platform camera interface device drivers.
 #
-EXTRA_AFLAGS=-mfloat-abi=softfp -mfpu=neon
 amlflash-objs := common/flashlight.o
 gt2005dri-objs := gt2005.o
 gc0307dri-objs := gc0307.o
diff -Naur linux-libreelec/drivers/amlogic/display/sys_led/aml_sysled.c linux-datrh/drivers/amlogic/display/sys_led/aml_sysled.c
--- linux-libreelec/drivers/amlogic/display/sys_led/aml_sysled.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/display/sys_led/aml_sysled.c	2017-08-30 21:17:34.000000000 +0200
@@ -63,9 +63,7 @@
 	LED_OFF,
 }led_mode_t;
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
 static struct aml_sysled *Myamlsysled = NULL;
-#endif
 static int sleep = 0;
 
 static int led_control(unsigned int led_mode )
@@ -157,7 +155,11 @@
 static int aml_sysled_suspend(struct platform_device *pdev,pm_message_t state)
 {
 	printk(KERN_INFO "enter aml_sysled_suspend\n");
+#ifdef CONFIG_HAS_EARLYSUSPEND
 	sleep = 2;
+#else
+	led_control(LED_RED);
+#endif
 	return 0;
 }
 
@@ -171,6 +173,12 @@
 	return 0;
 }
 
+static void aml_sysled_shutdown(struct platform_device *pdev,pm_message_t state)
+{
+	printk(KERN_INFO "enter aml_sysled_shutdown\n");
+	led_control(LED_RED);
+}
+
 static int aml_sysled_probe(struct platform_device *pdev)
 {
 	struct aml_sysled_platform_data *pdata;
@@ -269,9 +277,8 @@
 	early_suspend.suspend = aml_sysled_early_suspend;
 	early_suspend.resume = aml_sysled_late_resume;
 	register_early_suspend(&early_suspend);
-  
-	Myamlsysled = amlsysled;
 #endif
+	Myamlsysled = amlsysled;
 	ret = device_create_file(&pdev->dev, &dev_attr_io_val);
 	if (ret < 0)
 		printk(KERN_WARNING "asoc: failed to add io_val sysfs files\n");
@@ -308,6 +315,7 @@
 	.remove = __exit_p(aml_sysled_remove),
 	.suspend = aml_sysled_suspend,
 	.resume  = aml_sysled_resume,
+	.shutdown = aml_sysled_shutdown,
 };
 
 static int __init aml_sysled_init(void)
diff -Naur linux-libreelec/drivers/amlogic/display/vout/enc_clk_config.c linux-datrh/drivers/amlogic/display/vout/enc_clk_config.c
--- linux-libreelec/drivers/amlogic/display/vout/enc_clk_config.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/display/vout/enc_clk_config.c	2017-08-30 21:17:34.000000000 +0200
@@ -84,6 +84,7 @@
     aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x40238100);
     aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00012286);
     aml_write_reg32(P_HHI_VID2_PLL_CNTL2, 0x430a800);       // internal LDO share with HPLL & VIID PLL
+    aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0x21ef, 0, 15);
     switch(clk){
         case 2971:      // only for 4k mode
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
diff -Naur linux-libreelec/drivers/amlogic/display/vout/tvconf.c linux-datrh/drivers/amlogic/display/vout/tvconf.c
--- linux-libreelec/drivers/amlogic/display/vout/tvconf.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/display/vout/tvconf.c	2018-06-05 21:45:54.000000000 +0200
@@ -425,7 +425,7 @@
         .aspect_ratio_den  = 9,
         .sync_duration_num = 24000,
         .sync_duration_den = 1001,
-        .video_clk         = 74250000,
+        .video_clk         = 74176000,//74250000,
     },
 #endif
     { /* VMODE_4K2K_30HZ */
diff -Naur linux-libreelec/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c linux-datrh/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c
--- linux-libreelec/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c	2018-06-06 07:12:22.000000000 +0200
+++ linux-datrh/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c	2017-08-30 21:17:34.000000000 +0200
@@ -39,20 +39,21 @@
 
 #define CONFIG_TV_DEBUG // for verbose output
 //#undef CONFIG_TV_DEBUG
-unsigned long amlogic_cec_debug_flag = 1;
 
 MODULE_AUTHOR("Gerald Dachs");
 MODULE_DESCRIPTION("Amlogic CEC driver");
 MODULE_LICENSE("GPL");
 
-//unused, only left to satisfy the linker
-bool cec_msg_dbg_en = 1;
+bool cec_msg_dbg_en = 0;
+
+MODULE_PARM_DESC(cec_msg_dbg_en, "\n cec_msg_dbg_en\n");
+module_param(cec_msg_dbg_en, bool, 0664);
 
 #define DRV_NAME "amlogic_cec"
 #ifndef amlogic_cec_log_dbg
 #define amlogic_cec_log_dbg(fmt, ...) \
-    if (amlogic_cec_debug_flag)       \
-	printk(KERN_INFO "[%s] %s(): " fmt, DRV_NAME, __func__, ##__VA_ARGS__)
+    if (cec_msg_dbg_en)       \
+        printk(KERN_INFO "[%s] %s(): " fmt, DRV_NAME, __func__, ##__VA_ARGS__)
 #endif
 
 #define CEC_IOC_MAGIC        'c'
@@ -60,7 +61,7 @@
 #define CEC_IOC_GETPADDR     _IO(CEC_IOC_MAGIC, 1)
 
 #define VERSION   "0.0.1" /* Driver version number */
-#define CEC_MINOR 243	/* Major 10, Minor 242, /dev/cec */
+#define CEC_MINOR 243        /* Major 10, Minor 242, /dev/cec */
 
 /* CEC Rx buffer size */
 #define CEC_RX_BUFF_SIZE            16
@@ -70,29 +71,29 @@
 static DEFINE_SEMAPHORE(init_mutex);
 
 struct cec_rx_list {
-	u8 buffer[CEC_RX_BUFF_SIZE];
-	unsigned char size;
-	struct list_head list;
+        u8 buffer[CEC_RX_BUFF_SIZE];
+        unsigned char size;
+        struct list_head list;
 };
 
 struct cec_rx_struct {
-	spinlock_t lock;
-	wait_queue_head_t waitq;
-	atomic_t state;
-	struct list_head list;
+        spinlock_t lock;
+        wait_queue_head_t waitq;
+        atomic_t state;
+        struct list_head list;
 };
 
 struct cec_tx_struct {
-	spinlock_t lock;
-	wait_queue_head_t waitq;
-	atomic_t state;
+        spinlock_t lock;
+        wait_queue_head_t waitq;
+        atomic_t state;
 };
 
 enum cec_state {
-	STATE_RX,
-	STATE_TX,
-	STATE_DONE,
-	STATE_ERROR
+        STATE_RX,
+        STATE_TX,
+        STATE_DONE,
+        STATE_ERROR
 };
 
 static char banner[] __initdata =
@@ -102,6 +103,8 @@
 
 static struct cec_tx_struct cec_tx_struct;
 
+static struct hrtimer cec_late_timer;
+
 static atomic_t hdmi_on = ATOMIC_INIT(0);
 
 cec_global_info_t cec_global_info;
@@ -118,26 +121,6 @@
     atomic_set(&cec_tx_struct.state, state);
 }
 
-static void amlogic_cec_msg_dump(char * msg_tag, const unsigned char *data, unsigned char count)
-{
-  int i;
-  int pos;
-  unsigned char msg_log_buf[128] = { 0 };
-
-  if (amlogic_cec_debug_flag == 1)
-  {
-      pos = 0;
-      pos += sprintf(msg_log_buf + pos, "msg %s len: %d   dat: ", msg_tag, count);
-      for (i = 0; i < count; ++i)
-      {
-          pos += sprintf(msg_log_buf + pos, "%02x ", data[i]);
-      }
-      pos += sprintf(msg_log_buf + pos, "\n");
-      msg_log_buf[pos] = '\0';
-      hdmi_print(INF, "[amlogic_cec] dump: %s", msg_log_buf);
-  }
-}
-
 static unsigned int amlogic_cec_read_reg(unsigned int reg)
 {
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
@@ -158,169 +141,126 @@
 #endif
 }
 
-static int amlogic_cec_read_hw(unsigned char *data, unsigned char *count)
+static int amlogic_cec_read_hw()
 {
-    int ret = -1;
-    int valid_msg;
-    int rx_msg_status;
-    int rx_num_msg;
-
-    rx_msg_status = amlogic_cec_read_reg(CEC_RX_MSG_STATUS);
-    rx_num_msg = amlogic_cec_read_reg(CEC_RX_NUM_MSG);
-
-    amlogic_cec_log_dbg("rx_msg_status: %d, rx_num_msg: %d\n", rx_msg_status, rx_num_msg);
-
-    valid_msg = (RX_DONE == rx_msg_status) && (1 == rx_num_msg);
+    int retval = 0;
+    unsigned long spin_flags;
+    struct cec_rx_list *entry;
 
-    if (valid_msg)
+    if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
     {
-      int i;
-
-      *count = amlogic_cec_read_reg(CEC_RX_MSG_LENGTH) + 1;
-      for (i = 0; i < (*count) && i < CEC_RX_BUFF_SIZE; ++i)
-      {
-          data[i]= amlogic_cec_read_reg(CEC_RX_MSG_0_HEADER + i);
-      }
-
-      amlogic_cec_msg_dump("RX", data, *count);
+        amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
+        retval = -1;
+    }
 
-      ret = RX_DONE;
+    if ((-1) == cec_ll_rx(entry->buffer, &entry->size))
+    {
+        kfree(entry);
+        cec_rx_buf_clear();
     }
+    else
+    {
+        INIT_LIST_HEAD(&entry->list);
+        spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+        list_add_tail(&entry->list, &cec_rx_struct.list);
+        amlogic_cec_set_rx_state(STATE_DONE);
+        spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 2));
-#endif
-    amlogic_cec_write_reg(CEC_RX_MSG_CMD, valid_msg ? RX_ACK_NEXT : RX_ACK_CURRENT);
-    amlogic_cec_write_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+        wake_up_interruptible(&cec_rx_struct.waitq);
+    }
 
-    return ret;
+    return retval;
 }
 
-
-static void amlogic_cec_write_hw(const char *data, size_t count)
+static void amlogic_cec_set_logical_addr(unsigned int logical_addr)
 {
-  int i;
-
-  for (i = 0; i < count; ++i)
-  {
-      amlogic_cec_write_reg(CEC_TX_MSG_0_HEADER + i, data[i]);
-  }
-  amlogic_cec_write_reg(CEC_TX_MSG_LENGTH, count - 1);
-  amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_REQ_CURRENT);
-
-  amlogic_cec_msg_dump("TX", data, count);
+    amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | logical_addr);
+    cec_global_info.my_node_index = logical_addr;
 }
 
 unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
 {
-// unused, just to satisfy the linker
-  return log_addr;
+    // unused, just to satisfy the linker
+    return log_addr;
 }
 
-void cec_node_init(hdmitx_dev_t* hdmitx_device)
+static enum hrtimer_restart cec_late_check_rx_buffer(struct hrtimer *timer)
 {
-    unsigned long cec_phy_addr;
-    unsigned long spin_flags;
-    struct cec_rx_list *entry;
-
-    cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12)
-                 | (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)
-                 | (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)
-                 | (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
-
-    // If VSDB is not valid,use last or default physical address.
-    if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0)
-    {
-	amlogic_cec_log_dbg("no valid cec physical address\n");
-	if (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)
-	{
-	    amlogic_cec_log_dbg("use last physical address\n");
-	}
-	else
-	{
-	    aml_write_reg32(P_AO_DEBUG_REG1, (aml_read_reg32(P_AO_DEBUG_REG1) & (0xf << 16)) | 0x1000);
-	    amlogic_cec_log_dbg("use default physical address\n");
-	}
+    if (cec_rx_buf_check())
+    {
+        /*
+         * start another check if rx buffer is full
+         */
+        if ((-1) == amlogic_cec_read_hw())
+        {
+            return HRTIMER_NORESTART;
+        }
     }
-    else
+    if (atomic_read(&hdmi_on))
     {
-	if (cec_global_info.my_node_index)
-	{
-	    // prevent write operations
-	    if (down_interruptible(&init_mutex))
-	    {
-		printk(KERN_ERR "[amlogic] ##### cec node init interrupted! #####\n");
-		return;
-	    }
-	    hdmitx_device->cec_init_ready = 0;
-            spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
-
-	    amlogic_cec_log_dbg("start reset\n");
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-	    aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)|(1<<16));
-	    hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_CTRL0, 0xc); //[3]cec_creg_sw_rst [2]cec_sys_sw_rst
-
-#if 0
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_CLEAR_BUF, 0x1);
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_RX_CLEAR_BUF, 0x1);
+        hrtimer_start(&cec_late_timer, ktime_set(0, 384*1000*1000), HRTIMER_MODE_REL);
+    }
 
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_CLEAR_BUF, 0x0);
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_RX_CLEAR_BUF, 0x0);
-#endif
+    return HRTIMER_NORESTART;
+}
 
-	    hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_CTRL0, 0x0);
-	    aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)&(~(1<<16)));
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
+void cec_node_init(hdmitx_dev_t* hdmitx_device)
+{
+    unsigned long cec_phy_addr;
 
+    if (atomic_read(&hdmi_on) && (0 == hdmitx_device->cec_init_ready))
+    {
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+        cec_gpi_init();
+        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1);
+        // Clear CEC Int. state and set CEC Int. mask
+        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
+        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
 #endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	    // regain rx interrupts
-	    cec_enable_irq();
+        // GPIOAO_12
+        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 0, 14, 1);       // bit[14]: AO_PWM_C pinmux                  //0xc8100014
+        aml_set_reg32_bits(P_AO_RTI_PULL_UP_REG, 1, 12, 1);       // bit[12]: enable AO_12 internal pull-up   //0xc810002c
+        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 17, 1);       // bit[17]: AO_CEC pinmux                    //0xc8100014
+        ao_cec_init();
+        cec_arbit_bit_time_set(3, 0x118, 0);
+        cec_arbit_bit_time_set(5, 0x000, 0);
+        cec_arbit_bit_time_set(7, 0x2aa, 0);
 #endif
-            spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+        cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12)
+                     | (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)
+                     | (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)
+                     | (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
 
-            hdmitx_device->cec_init_ready = 1;
+        // If VSDB is not valid,use last or default physical address.
+        if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0)
+        {
+            amlogic_cec_log_dbg("no valid cec physical address\n");
+            if (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)
+            {
+                amlogic_cec_log_dbg("use last physical address\n");
+            }
+            else
+            {
+                aml_write_reg32(P_AO_DEBUG_REG1, (aml_read_reg32(P_AO_DEBUG_REG1) & (0xf << 16)) | 0x1000);
+                amlogic_cec_log_dbg("use default physical address\n");
+            }
+        }
+        else
+        {
+            if ((aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff) != cec_phy_addr)
+            {
+                aml_write_reg32(P_AO_DEBUG_REG1, (aml_read_reg32(P_AO_DEBUG_REG1) & (0xf << 16)) | cec_phy_addr);
+                amlogic_cec_log_dbg("physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff);
+            }
+        }
 
-	    up(&init_mutex);
-	    amlogic_cec_log_dbg("stop reset\n");
-	}
-
-	if ((aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff) != cec_phy_addr)
-	{
-	    aml_write_reg32(P_AO_DEBUG_REG1, (aml_read_reg32(P_AO_DEBUG_REG1) & (0xf << 16)) | cec_phy_addr);
-	    amlogic_cec_log_dbg("physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff);
-
-	    if ((hdmitx_device->cec_init_ready != 0) && (hdmitx_device->hpd_state != 0))
-	    {
-		if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
-		{
-		    amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
-		}
-		else
-		{
-		    // let the libCEC ask for new physical Address
-		    entry->buffer[0] = 0xff;
-		    entry->size = 1;
-		    INIT_LIST_HEAD(&entry->list);
-
-		    spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
-		    list_add_tail(&entry->list, &cec_rx_struct.list);
-		    amlogic_cec_set_rx_state(STATE_DONE);
-		    spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
-
-		    amlogic_cec_log_dbg("trigger libCEC\n");
-		    wake_up_interruptible(&cec_rx_struct.waitq);
-		}
-	    }
-	}
+        hdmitx_device->cec_init_ready = 1;
     }
 }
 
 static irqreturn_t amlogic_cec_irq_handler(int irq, void *dummy)
 {
-    unsigned long spin_flags;
-    struct cec_rx_list *entry;
     unsigned int tx_msg_state;
     unsigned int rx_msg_state;
 
@@ -335,45 +275,28 @@
 
     if ((tx_msg_state == TX_DONE) || (tx_msg_state == TX_ERROR))
     {
-	amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        switch (tx_msg_state) {
+          case TX_ERROR :
+            amlogic_cec_set_tx_state(STATE_ERROR);
+            break;
+          case TX_DONE :
+            amlogic_cec_set_tx_state(STATE_DONE);
+            break;
+        }
+        wake_up_interruptible(&cec_tx_struct.waitq);
+    }
 
-	switch (tx_msg_state) {
-	  case TX_ERROR :
-	    amlogic_cec_set_tx_state(STATE_ERROR);
-	    break;
-	  case TX_DONE :
-	    amlogic_cec_set_tx_state(STATE_DONE);
-	    break;
-	}
-	wake_up_interruptible(&cec_tx_struct.waitq);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    if (aml_read_reg32(P_AO_CEC_INTR_STAT) & (1<<1))
+    {   // aocec tx intr
+        tx_irq_handle();
+        return IRQ_HANDLED;
     }
+#endif
 
     if (rx_msg_state == RX_DONE)
     {
-
-	if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
-	{
-	    amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
-	    return IRQ_HANDLED;
-	}
-
-	INIT_LIST_HEAD(&entry->list);
-
-	spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
-
-	if ((-1) == amlogic_cec_read_hw(entry->buffer, &entry->size))
-	{
-	    kfree(entry);
-	    amlogic_cec_log_dbg("amlogic_cec_irq_handler: nothing to read\n");
-            spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
-	    return IRQ_HANDLED;
-	}
-
-	list_add_tail(&entry->list, &cec_rx_struct.list);
-	amlogic_cec_set_rx_state(STATE_DONE);
-	spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
-
-	wake_up_interruptible(&cec_rx_struct.waitq);
+        amlogic_cec_read_hw();
     }
 
     return IRQ_HANDLED;
@@ -382,71 +305,66 @@
 static int amlogic_cec_open(struct inode *inode, struct file *file)
 {
     int ret = 0;
+    unsigned long spin_flags;
+    struct cec_rx_list* entry = NULL;
 
     if (atomic_read(&hdmi_on))
     {
-	amlogic_cec_log_dbg("do not allow multiple open for tvout cec\n");
-	ret = -EBUSY;
+        amlogic_cec_log_dbg("do not allow multiple open for tvout cec\n");
+        ret = -EBUSY;
     }
     else
     {
-	atomic_inc(&hdmi_on);
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-        if (request_irq(INT_HDMI_CEC, &amlogic_cec_irq_handler,
-        IRQF_SHARED, "amhdmitx-cec",(void *)hdmitx_device))
-        {
-    	    amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
-            return -EFAULT;
-        }
-#endif
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-        if (request_irq(INT_AO_CEC, &amlogic_cec_irq_handler,
-        IRQF_SHARED, "amhdmitx-aocec",(void *)hdmitx_device))
+        atomic_inc(&hdmi_on);
+
+        spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+        while(!list_empty(&cec_rx_struct.list))
         {
-    	    amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
-            return -EFAULT;
+            entry = list_first_entry(&cec_rx_struct.list, struct cec_rx_list, list);
+            list_del(&entry->list);
+            kfree(entry);
         }
-#endif
+        spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
 
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-        cec_gpi_init();
-#endif
+        cec_node_init(hdmitx_device);
 
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1);
-        // Clear CEC Int. state and set CEC Int. mask
-        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
-        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
-#endif
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-// GPIOAO_12
-        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 0, 14, 1);       // bit[14]: AO_PWM_C pinmux                  //0xc8100014
-        aml_set_reg32_bits(P_AO_RTI_PULL_UP_REG, 1, 12, 1);       // bit[12]: enable AO_12 internal pull-up   //0xc810002c
-        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 17, 1);       // bit[17]: AO_CEC pinmux                    //0xc8100014
-        ao_cec_init();
-        cec_arbit_bit_time_set(3, 0x118, 0);
-        cec_arbit_bit_time_set(5, 0x000, 0);
-        cec_arbit_bit_time_set(7, 0x2aa, 0);
-#endif
-        amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+        cec_enable_irq();
 
-        hdmitx_device->cec_init_ready = 1;
+        amlogic_cec_set_logical_addr(0xf);
 
+        if (hdmitx_device->hpd_state != 0)
+        {
+            if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
+            {
+                amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
+            }
+            else
+            {
+                // let the libCEC ask for new physical Address
+                entry->buffer[0] = 0xff;
+                entry->size = 1;
+                INIT_LIST_HEAD(&entry->list);
+
+                spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+                list_add_tail(&entry->list, &cec_rx_struct.list);
+                amlogic_cec_set_rx_state(STATE_DONE);
+                spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+
+                amlogic_cec_log_dbg("trigger libCEC\n");
+                wake_up_interruptible(&cec_rx_struct.waitq);
+            }
+        }
+
+        hrtimer_start(&cec_late_timer, ktime_set(0, 384*1000*1000), HRTIMER_MODE_REL);
     }
     return ret;
 }
 
 static int amlogic_cec_release(struct inode *inode, struct file *file)
 {
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
-    free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
-#endif
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    free_irq(INT_AO_CEC, (void *)hdmitx_device);
-#endif
+    amlogic_cec_set_logical_addr(0xf);
 
-    amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+    cec_disable_irq();
 
     atomic_dec(&hdmi_on);
 
@@ -454,17 +372,17 @@
 }
 
 static ssize_t amlogic_cec_read(struct file *file, char __user *buffer,
-				size_t count, loff_t *ppos)
+                                size_t count, loff_t *ppos)
 {
     ssize_t retval;
     unsigned long spin_flags;
     struct cec_rx_list* entry = NULL;
 
     if (wait_event_interruptible(cec_rx_struct.waitq,
-				 atomic_read(&cec_rx_struct.state) == STATE_DONE))
+                                 atomic_read(&cec_rx_struct.state) == STATE_DONE))
     {
-	amlogic_cec_log_dbg("error during wait on state change\n");
-	return -ERESTARTSYS;
+        amlogic_cec_log_dbg("error during wait on state change\n");
+        return -ERESTARTSYS;
     }
 
     spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
@@ -473,53 +391,53 @@
 
     if (entry == NULL || entry->size > count)
     {
-	amlogic_cec_log_dbg("entry is NULL, or empty\n");
-	retval = -1;
-	goto error_exit;
+        amlogic_cec_log_dbg("entry is NULL, or empty\n");
+        retval = -1;
+        goto error_exit;
     }
 
     if (copy_to_user(buffer, entry->buffer, entry->size))
     {
-	printk(KERN_ERR " copy_to_user() failed!\n");
+        printk(KERN_ERR " copy_to_user() failed!\n");
 
-	retval = -EFAULT;
-	goto error_exit;
+        retval = -EFAULT;
+        goto error_exit2;
     }
 
     retval = entry->size;
 
-
 error_exit:
     if (entry != NULL)
     {
-    	list_del(&entry->list);
-    	kfree(entry);
+            list_del(&entry->list);
+            kfree(entry);
     }
 
     if (list_empty(&cec_rx_struct.list))
     {
-        amlogic_cec_set_rx_state(STATE_RX);
+            amlogic_cec_set_rx_state(STATE_RX);
     }
 
+error_exit2:
     spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
 
     return retval;
 }
 
 static ssize_t amlogic_cec_write(struct file *file, const char __user *buffer,
-			size_t count, loff_t *ppos)
+                        size_t count, loff_t *ppos)
 {
     int retval = count;
     char data[CEC_TX_BUFF_SIZE];
 
     /* check data size */
     if (count > CEC_TX_BUFF_SIZE || count == 0)
-	return -1;
+        return -1;
 
     if (copy_from_user(data, buffer, count))
     {
-	printk(KERN_ERR " copy_from_user() failed!\n");
-	return -EFAULT;
+        printk(KERN_ERR " copy_from_user() failed!\n");
+        return -EFAULT;
     }
 
     amlogic_cec_set_tx_state(STATE_TX);
@@ -527,28 +445,25 @@
     // don't write if cec_node_init() is in progress
     if (down_interruptible(&init_mutex))
     {
-	amlogic_cec_log_dbg("error during wait on state change\n");
-	printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
-	return -ERESTARTSYS;
+        amlogic_cec_log_dbg("error during wait on state change\n");
+        return -ERESTARTSYS;
     }
 
-    amlogic_cec_write_hw(data, count);
+    cec_ll_tx(data, count);
 
     if (wait_event_interruptible_timeout(cec_tx_struct.waitq,
         atomic_read(&cec_tx_struct.state) != STATE_TX, 2 * HZ) <= 0)
     {
-	amlogic_cec_log_dbg("error during wait on state change, resetting\n");
-	printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
-	amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_ABORT); // stop cec tx for hw retry.
-	amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-	retval = -ERESTARTSYS;
-	goto error_exit;
+        amlogic_cec_log_dbg("error during wait on state change, resetting\n");
+        cec_hw_reset();
+        retval = -ERESTARTSYS;
+        goto error_exit;
     }
 
     if (atomic_read(&cec_tx_struct.state) != STATE_DONE)
     {
-	printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
-	retval = -1;
+        amlogic_cec_log_dbg("##### cec write error! #####\n");
+        retval = -1;
     }
 
 error_exit:
@@ -558,7 +473,7 @@
 }
 
 static long amlogic_cec_ioctl(struct file *file, unsigned int cmd,
-						unsigned long arg)
+                                                unsigned long arg)
 {
     unsigned char logical_addr;
     unsigned int reg;
@@ -571,8 +486,7 @@
             return -EFAULT;
         }
 
-        amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | logical_addr);
-        cec_global_info.my_node_index = logical_addr;
+        amlogic_cec_set_logical_addr(logical_addr);
         /*
          * use DEBUG_REG1 bit 16 ~ 31 to save logic address.
          * So uboot can use this logic address directly
@@ -586,7 +500,7 @@
 
     case CEC_IOC_GETPADDR:
         amlogic_cec_log_dbg("amlogic_cec_ioctl: return physical address 0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff);
-    	return aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff;
+            return aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff;
     }
 
     return -EINVAL;
@@ -594,15 +508,16 @@
 
 static u32 amlogic_cec_poll(struct file *file, poll_table *wait)
 {
-
-    if (atomic_read(&cec_rx_struct.state) != STATE_DONE)
+    if (atomic_read(&cec_rx_struct.state) == STATE_DONE)
     {
-        poll_wait(file, &cec_rx_struct.waitq, wait);
+        return POLLIN | POLLRDNORM;
     }
 
+    poll_wait(file, &cec_rx_struct.waitq, wait);
+
     if (atomic_read(&cec_rx_struct.state) == STATE_DONE)
     {
-	return POLLIN | POLLRDNORM;
+        return POLLIN | POLLRDNORM;
     }
     return 0;
 }
@@ -630,7 +545,7 @@
 
     if (down_interruptible(&init_mutex))
     {
-      return -ERESTARTSYS;
+        return -ERESTARTSYS;
     }
 
     INIT_LIST_HEAD(&cec_rx_struct.list);
@@ -640,7 +555,7 @@
     hdmitx_device = get_hdmitx_device();
     amlogic_cec_log_dbg("CEC init\n");
 
-    amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+    amlogic_cec_set_logical_addr(0xf);
 
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
@@ -657,9 +572,29 @@
 
     if (misc_register(&cec_misc_device))
     {
-	printk(KERN_WARNING " Couldn't register device 10, %d.\n", CEC_MINOR);
-	retval = -EBUSY;
+        printk(KERN_WARNING " Couldn't register device 10, %d.\n", CEC_MINOR);
+        retval = -EBUSY;
+    }
+
+    hrtimer_init(&cec_late_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    cec_late_timer.function = cec_late_check_rx_buffer;
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    if (request_irq(INT_HDMI_CEC, &amlogic_cec_irq_handler,
+        IRQF_SHARED, "amhdmitx-cec",(void *)hdmitx_device))
+    {
+        amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
+    }
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    if (request_irq(INT_AO_CEC, &amlogic_cec_irq_handler,
+        IRQF_SHARED, "amhdmitx-aocec",(void *)hdmitx_device))
+    {
+        amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
     }
+#endif
 
     // release initial lock on init_mutex
     up(&init_mutex);
@@ -671,6 +606,13 @@
 
 static void amlogic_cec_exit(void)
 {
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
+    free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    free_irq(INT_AO_CEC, (void *)hdmitx_device);
+#endif
     misc_deregister(&cec_misc_device);
 }
 
diff -Naur linux-libreelec/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c linux-datrh/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
--- linux-libreelec/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c	2018-06-06 07:12:22.000000000 +0200
+++ linux-datrh/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c	2017-08-30 21:17:34.000000000 +0200
@@ -590,19 +590,6 @@
     pos+=snprintf(buf+pos, PAGE_SIZE, "%x\n",cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang);
     return pos;
 }
-#else
-
-extern unsigned long amlogic_cec_debug_flag;
-
-static ssize_t show_amlogic_cec_debug_config(struct device *dev, struct device_attribute *attr, char *buf)
-{
-    return snprintf(buf, PAGE_SIZE, "amlogic_cec_debug:%lu\n", amlogic_cec_debug_flag);
-}
-
-static ssize_t store_amlogic_cec_debug_config(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
-{
-   return kstrtoul(buf, 16, &amlogic_cec_debug_flag) ? 0 : count;
-}
 #endif
 
 /*aud_mode attr*/
@@ -983,8 +970,6 @@
 static DEVICE_ATTR(cec_config, S_IWUSR | S_IRUGO | S_IWGRP, show_cec_config, store_cec_config);
 //static DEVICE_ATTR(cec_config, S_IWUGO | S_IRUGO , NULL, store_cec_config);
 static DEVICE_ATTR(cec_lang_config, S_IWUSR | S_IRUGO | S_IWGRP, show_cec_lang_config, store_cec_lang_config);
-#else
-static DEVICE_ATTR(amlogic_cec_debug_config, S_IWUSR | S_IRUGO | S_IWGRP, show_amlogic_cec_debug_config, store_amlogic_cec_debug_config);
 #endif
 
 /*****************************
@@ -1502,11 +1487,6 @@
         return 1;
     }
 
-    ret = of_property_read_u32(np, "cec_config", &(vend->cec_config));
-    if(ret) {
-        hdmi_print(INF, SYS "not find cec config\n");
-        return 1;
-    }
     ret = of_property_read_u32(np, "ao_cec", &(vend->ao_cec));
     if(ret) {
         hdmi_print(INF, SYS "not find ao cec\n");
@@ -1674,8 +1654,6 @@
     ret=device_create_file(hdmitx_dev, &dev_attr_cec);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_config);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_lang_config);
-#else
-    ret=device_create_file(hdmitx_dev, &dev_attr_amlogic_cec_debug_config);
 #endif
 
     if (hdmitx_dev == NULL) {
@@ -1864,6 +1842,23 @@
 }
 #endif
 
+static int amhdmitx_shutdown(struct platform_device *pdev,pm_message_t state)
+{
+    const vinfo_t *info = hdmi_get_current_vinfo();
+    if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0))
+        return;
+    hdmitx_device.hpd_lock = 1;
+    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_EARLY_SUSPEND);
+    hdmitx_device.cur_VIC = HDMI_Unkown;
+    hdmitx_device.output_blank_flag = 0;
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, DDC_RESET_HDCP);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
+    hdmi_print(IMP, SYS "HDMITX: shutdown\n");
+    return 0;
+}
+
 #ifdef CONFIG_OF
 static const struct of_device_id meson_amhdmitx_dt_match[]={
     {
@@ -1881,6 +1876,7 @@
     .suspend    = amhdmitx_suspend,
     .resume     = amhdmitx_resume,
 #endif
+    .shutdown	= amhdmitx_shutdown,
     .driver     = {
         .name   = DEVICE_NAME,
             .owner    = THIS_MODULE,
diff -Naur linux-libreelec/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c linux-datrh/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
--- linux-libreelec/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c	2017-08-30 21:17:34.000000000 +0200
@@ -226,15 +226,6 @@
         vend_data = hdmitx_device->config_data.vend_data;
     }
 
-    if ((vend_data) && (vend_data->cec_config))
-    {
-        //hdmitx_device->cec_func_config = vend_data->cec_config;
-        //aml_write_reg32(P_AO_DEBUG_REG0, vend_data->cec_config);
-        //hdmi_print(INF, CEC "cec_func_config: 0x%x; P_AO_DEBUG_REG0:0x%x\n", hdmitx_device->cec_func_config, aml_read_reg32(P_AO_DEBUG_REG0));
-    }
-
-    //hdmi_print(INF, CEC "cec_config: 0x%x; ao_cec:0x%x\n", vend_data->cec_config, vend_data->ao_cec);
-
     if ((vend_data) && (vend_data->cec_osd_string))
     {
         i = strlen(vend_data->cec_osd_string);
@@ -348,6 +339,18 @@
             cec_device_vendor_id((cec_rx_message_t*)0);
 
             msleep(150);
+
+	    /* Disable switch TV on automatically */
+	    if (!(hdmitx_device->cec_func_config & (1 << AUTO_POWER_ON_MASK))) {
+		cec_usrcmd_get_device_power_status(CEC_TV_ADDR);
+		wait_event_interruptible(hdmitx_device->cec_wait_rx,
+			cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos);
+		cec_isr_post_process();
+
+		if (cec_global_info.tv_power_status)
+		    return;
+	    }
+
             cec_imageview_on_smp();
             msleep(100);
 
@@ -1193,7 +1196,7 @@
 
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_DECK_STATUS;
-    msg[2] = 0x1a;
+    msg[2] = 0x20;
     cec_ll_tx(msg, 3);
 }
 
@@ -1335,6 +1338,7 @@
             case CEC_OC_REPORT_PHYSICAL_ADDRESS:
                 break;
             case CEC_OC_REPORT_POWER_STATUS:
+	    cec_global_info.tv_power_status = pcec_message->content.msg.operands[0];
                 break;
             case CEC_OC_SET_OSD_NAME:
                 break;
@@ -1425,6 +1429,15 @@
                         break;
                 }
                 break;
+            case CEC_OC_VENDOR_COMMAND:
+                if (pcec_message->content.msg.operands[0] == 0x1) {
+                    cec_report_power_status(pcec_message);
+                    cec_send_simplink_alive(pcec_message);
+                } else if (pcec_message->content.msg.operands[0]
+                                == 0x4) {
+                    cec_send_simplink_ack(pcec_message);
+                }
+                break;
             case CEC_OC_GET_MENU_LANGUAGE:
             case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
             case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
@@ -1444,7 +1457,6 @@
             case CEC_OC_TUNER_DEVICE_STATUS:
             case CEC_OC_TUNER_STEP_DECREMENT:
             case CEC_OC_TUNER_STEP_INCREMENT:
-            case CEC_OC_VENDOR_COMMAND:
             case CEC_OC_SELECT_ANALOGUE_SERVICE:
             case CEC_OC_SELECT_DIGITAL_SERVICE:
             case CEC_OC_SET_ANALOGUE_TIMER :
@@ -1773,6 +1785,31 @@
     cec_ll_tx(gbl_msg, 2);
 }
 
+void cec_send_simplink_alive(cec_rx_message_t *pcec_message)
+{
+	unsigned char index = cec_global_info.my_node_index;
+	unsigned char msg[4];
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_VENDOR_COMMAND;
+	msg[2] = 0x2;
+	msg[3] = 0x5;
+
+	cec_ll_tx(msg, 4);
+}
+
+void cec_send_simplink_ack(cec_rx_message_t *pcec_message)
+{
+	unsigned char index = cec_global_info.my_node_index;
+	unsigned char msg[4];
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_VENDOR_COMMAND;
+	msg[2] = 0x5;
+	msg[3] = 0x1;
+
+	cec_ll_tx(msg, 4);
+}
 /***************************** cec middle level code end *****************************/
 
 
diff -Naur linux-libreelec/drivers/amlogic/ionvideo/Makefile linux-datrh/drivers/amlogic/ionvideo/Makefile
--- linux-libreelec/drivers/amlogic/ionvideo/Makefile	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/ionvideo/Makefile	2017-08-30 21:17:34.000000000 +0200
@@ -1,4 +1,2 @@
-EXTRA_AFLAGS=-mfloat-abi=softfp -mfpu=neon
-
 obj-$(CONFIG_VIDEOBUF2_ION) += videobuf2-ion.o
 obj-$(CONFIG_AMLOGIC_IONVIDEO) += ionvideo.o ppmgr2.o
diff -Naur linux-libreelec/drivers/amlogic/mipi/Makefile linux-datrh/drivers/amlogic/mipi/Makefile
--- linux-libreelec/drivers/amlogic/mipi/Makefile	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/mipi/Makefile	2017-08-30 21:17:34.000000000 +0200
@@ -1,7 +1,6 @@
 #
 # Makefile for Amlogic MIPI.
 #
-EXTRA_AFLAGS=-mfloat-abi=softfp -mfpu=neon
 aml_mipi-objs := am_mipi_csi2.o
 aml_mipi_mem-objs := mem/mipi_mem.o mem/convert_mem.o mem/swap_mem.o
 aml_mipi_vdin-objs := vdin/mipi_vdin.o vdin/convert_vdin.o vdin/swap_vdin_y.o vdin/swap_vdin_uv.o vdin/csi.o
diff -Naur linux-libreelec/drivers/amlogic/video_dev/Makefile linux-datrh/drivers/amlogic/video_dev/Makefile
--- linux-libreelec/drivers/amlogic/video_dev/Makefile	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/drivers/amlogic/video_dev/Makefile	2017-08-30 21:17:34.000000000 +0200
@@ -1,7 +1,6 @@
 #
 # Makefile for the amlogic video device interface device drivers.
 #
-EXTRA_AFLAGS=-mfloat-abi=softfp -mfpu=neon
 amlvideodri-objs := amlvideo.o
 amlcm-objs := common/vfutil.o
 amlvideo2dri-objs := amlvideo2.o
diff -Naur linux-libreelec/sound/core/control.c linux-datrh/sound/core/control.c
--- linux-libreelec/sound/core/control.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/core/control.c	2018-06-05 21:45:46.000000000 +0200
@@ -1088,7 +1088,7 @@
 		mutex_lock(&ue->card->user_ctl_lock);
 		change = ue->tlv_data_size != size;
 		if (!change)
-			change = memcmp(ue->tlv_data, new_data, size) != 0;
+			change = memcmp(ue->tlv_data, new_data, size);
 		kfree(ue->tlv_data);
 		ue->tlv_data = new_data;
 		ue->tlv_data_size = size;
diff -Naur linux-libreelec/sound/core/seq/seq_clientmgr.c linux-datrh/sound/core/seq/seq_clientmgr.c
--- linux-libreelec/sound/core/seq/seq_clientmgr.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/core/seq/seq_clientmgr.c	2018-06-05 21:45:53.000000000 +0200
@@ -1248,7 +1248,6 @@
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_info info;
 	struct snd_seq_port_callback *callback;
-	int port_idx;
 
 	if (copy_from_user(&info, arg, sizeof(info)))
 		return -EFAULT;
@@ -1262,9 +1261,7 @@
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info.kernel) {
-		port_idx = port->addr.port;
-		snd_seq_port_unlock(port);
-		snd_seq_delete_port(client, port_idx);
+		snd_seq_delete_port(client, port->addr.port);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
@@ -1286,7 +1283,6 @@
 
 	snd_seq_set_port_info(port, &info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
-	snd_seq_port_unlock(port);
 
 	if (copy_to_user(arg, &info, sizeof(info)))
 		return -EFAULT;
diff -Naur linux-libreelec/sound/core/seq/seq_ports.c linux-datrh/sound/core/seq/seq_ports.c
--- linux-libreelec/sound/core/seq/seq_ports.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/core/seq/seq_ports.c	2017-08-30 21:17:34.000000000 +0200
@@ -122,9 +122,7 @@
 }
 
 
-/* create a port, port number is returned (-1 on failure);
- * the caller needs to unref the port via snd_seq_port_unlock() appropriately
- */
+/* create a port, port number is returned (-1 on failure) */
 struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
@@ -155,7 +153,6 @@
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
-	snd_use_lock_use(&new_port->use_lock);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
@@ -170,9 +167,9 @@
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
-	sprintf(new_port->name, "port-%d", num);
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
+	sprintf(new_port->name, "port-%d", num);
 
 	return new_port;
 }
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_audio_hw.c linux-datrh/sound/soc/aml/m8/aml_audio_hw.c
--- linux-libreelec/sound/soc/aml/m8/aml_audio_hw.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_audio_hw.c	2017-08-30 21:17:34.000000000 +0200
@@ -159,8 +159,8 @@
     if(channel == 8){
         printk(" %s channel == 8\n",__FUNCTION__);
         WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,       (24 << 16) |    // [31:16] IRQ block.
-                                (0xff << 8) |   // [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
-                                (0xff << 0));   // [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
+                                (((1 << channel) - 1) << 8) |   // [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
+                                (((1 << channel) - 1) << 0));   // [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
         }
     else 
         WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,       (24 << 16) |    // [31:16] IRQ block.
@@ -179,8 +179,10 @@
     audio_out_buf_ready = 1;
 }
 
-void audio_set_958outbuf(u32 addr, u32 size,int flag)
+void audio_set_958outbuf(u32 addr, u32 size, int channels, int flag)
 {
+	u8 chanmask;
+
     if (ENABLE_IEC958) {
         WRITE_MPEG_REG(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
         if(READ_MPEG_REG(AIU_MEM_IEC958_START_PTR) == READ_MPEG_REG(AIU_MEM_I2S_START_PTR)){
@@ -193,7 +195,8 @@
         }else{
             WRITE_MPEG_REG(AIU_MEM_IEC958_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 1);    // this is for RAW mode
         }
-        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_MASKS, 0x303, 0, 16);
+		chanmask = (1 << channels) - 1;
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_MASKS, chanmask << 8 | chanmask, 0, 16);
 
         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 0, 1);
         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 0, 1);
@@ -447,7 +450,7 @@
             WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 1, 5, 1);
         }
 
-        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_MASKS, mask[mode], 0, 16);
+//        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_MASKS, mask[mode], 0, 16);
 
         //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 0, 1);
         //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 0, 1);
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_audio_hw.h linux-datrh/sound/soc/aml/m8/aml_audio_hw.h
--- linux-libreelec/sound/soc/aml/m8/aml_audio_hw.h	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_audio_hw.h	2017-08-30 21:17:34.000000000 +0200
@@ -105,7 +105,7 @@
 extern unsigned I2S_MODE;
 
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel);
-void audio_set_958outbuf(u32 addr, u32 size, int flag);
+void audio_set_958outbuf(u32 addr, u32 size, int channels, int flag);
 void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode, u32 i2s_sync);
 void audio_in_spdif_set_buf(u32 addr, u32 size);
 void audio_in_i2s_enable(int flag);
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_i2s.c linux-datrh/sound/soc/aml/m8/aml_i2s.c
--- linux-libreelec/sound/soc/aml/m8/aml_i2s.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_i2s.c	2017-08-30 21:17:34.000000000 +0200
@@ -88,7 +88,7 @@
 // timer count: 16bits
 #define TIMER_COUNT    100
 
-#define USE_HW_TIMER
+//#define USE_HW_TIMER
 
 #ifdef USE_HW_TIMER
 static DEFINE_MUTEX(timer_mutex);
@@ -665,6 +665,16 @@
 extern void aml_hw_iec958_init(struct snd_pcm_substream *substream);
 extern void audio_hw_958_enable(unsigned flag);
 
+static char *get_hw_buf_ptr(struct snd_pcm_runtime *runtime, snd_pcm_uframes_t cur_pos, int align)
+{
+	unsigned int tot_bytes_per_channel = frames_to_bytes(runtime, cur_pos) / runtime->channels;
+	unsigned int bytes_aligned_per_channel = frames_to_bytes(runtime, align / runtime->channels);
+	unsigned int hw_base_off = tot_bytes_per_channel / bytes_aligned_per_channel;
+	unsigned int block_off = tot_bytes_per_channel % bytes_aligned_per_channel;
+
+	return runtime->dma_area + (frames_to_bytes(runtime, align) * hw_base_off) + block_off;
+}
+
 static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
                                  snd_pcm_uframes_t pos,
                                  void __user *buf, snd_pcm_uframes_t count, struct snd_pcm_substream *substream)
@@ -692,35 +702,21 @@
     }
     if (access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count))) {
         if (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
+       int16_t * tfrom, *to, *left;
+       int16_t *right = NULL;
 
-            int16_t * tfrom, *to, *left, *right;
-            tfrom = (int16_t*)ubuf;
-            to = (int16_t*)hwbuf;
-
-            left = to;
-            right = to + 16;
-            if (pos % align) {
-                printk("audio data unligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
-            }
-            if (set_android_gain_enable == 0) {
-                for (j = 0; j < n; j += 64) {
-                    for (i = 0; i < 16; i++) {
-                        *left++ = (*tfrom++) ;
-                        *right++ = (*tfrom++);
-                    }
-                    left += 16;
-                    right += 16;
-                }
-            } else {
-                for (j = 0; j < n; j += 64) {
-                    for (i = 0; i < 16; i++) {
-                        *left++ = (int16_t)(((*tfrom++) * android_left_gain) >> 8);
-                        *right++ = (int16_t)(((*tfrom++) * android_right_gain) >> 8);
-                    }
-                    left += 16;
-                    right += 16;
-                }
-            }
+	tfrom = (int16_t *) ubuf;
+
+	for (j = 0; j < count; j++) {
+		to = (int16_t *) get_hw_buf_ptr(runtime, pos + j, align);
+		left = to;
+		if (runtime->channels != 1)
+			right = to + align;
+
+		*left = (*tfrom++);
+		if (runtime->channels != 1)
+			*right = (*tfrom++);
+	}
         } else if (runtime->format == SNDRV_PCM_FORMAT_S24_LE && I2S_MODE == AIU_I2S_MODE_PCM24) {
             int32_t *tfrom, *to, *left, *right;
             tfrom = (int32_t*)ubuf;
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_m8.c linux-datrh/sound/soc/aml/m8/aml_m8.c
--- linux-libreelec/sound/soc/aml/m8/aml_m8.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_m8.c	2017-08-30 21:17:34.000000000 +0200
@@ -367,7 +367,6 @@
     struct aml_audio_private_data * p_aml_audio;
     int hp_state;
 
-    printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
     p_aml_audio = snd_soc_card_get_drvdata(card);
 	hp_state = p_aml_audio->detect_flag;
 
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_spdif_codec.c linux-datrh/sound/soc/aml/m8/aml_spdif_codec.c
--- linux-libreelec/sound/soc/aml/m8/aml_spdif_codec.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_spdif_codec.c	2017-08-30 21:17:34.000000000 +0200
@@ -25,8 +25,8 @@
 
 #define DRV_NAME "spdif-dit"
 
-#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
-#define STUB_FORMATS	SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE
+#define STUB_RATES	SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000
+#define STUB_FORMATS	SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE
 
 
 static struct snd_soc_codec_driver soc_codec_spdif_dit;
@@ -37,15 +37,15 @@
 	.name		= "dit-hifi",
 	.playback 	= {
 		.stream_name	= "Playback",
-		.channels_min	= 1,
-		.channels_max	= 8,
+		.channels_min	= 2,
+		.channels_max	= 2,
 		.rates		= STUB_RATES,
 		.formats	= STUB_FORMATS,
 	},
 	.capture 	= {
 		.stream_name	= "Capture",
-		.channels_min	= 1,
-		.channels_max	= 8,
+		.channels_min	= 2,
+		.channels_max	= 2,
 		.rates		= STUB_RATES,
 		.formats	= STUB_FORMATS,
 	},
diff -Naur linux-libreelec/sound/soc/aml/m8/aml_spdif_dai.c linux-datrh/sound/soc/aml/m8/aml_spdif_dai.c
--- linux-libreelec/sound/soc/aml/m8/aml_spdif_dai.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-datrh/sound/soc/aml/m8/aml_spdif_dai.c	2017-08-30 21:17:34.000000000 +0200
@@ -70,7 +70,7 @@
 	}
 	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
 	memset(iec958buf, 0, sizeof(iec958buf));
-	audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63), 128, 0);
+	audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63), 128, 2, 0);
 	audio_set_958_mode(AIU_958_MODE_PCM16, &set);
 #if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1
 	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 3, 4, 2);	/* 512fs divide 4 == 128fs */
@@ -274,7 +274,7 @@
 		}
 		start = buf->addr;
 		size = snd_pcm_lib_buffer_bytes(substream);
-		audio_set_958outbuf(start, size, 0);
+		audio_set_958outbuf(start, size, runtime->channels, 0);
 		/* audio_set_i2s_mode(AIU_I2S_MODE_PCM16); */
 		/* audio_set_aiubuf(start, size); */
 	} else {
@@ -306,7 +306,7 @@
 		}
 		start = buf->addr;
 		size = snd_pcm_lib_buffer_bytes(substream);
-		audio_set_958outbuf(start, size,
+		audio_set_958outbuf(start, size, runtime->channels,
 				    (iec958_mode == AIU_958_MODE_RAW) ? 1 : 0);
 		memset((void *)buf->area, 0, size);
 	}
